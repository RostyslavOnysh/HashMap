Так, написання методу resize, який буде збільшувати мапу і запобігати колізіям, може бути гарною ідеєю.

Метод resize може бути викликаний у методі put або в іншому відповідному місці,
коли досягнуто певного порогового значення для кількості елементів у мапі (наприклад, заснованого на факторі навантаження). При запуску resize він може створювати новий більший масив або іншу структуру даних для збереження більшого обсягу даних.

Окрім збільшення розміру мапи, resize також може перехешувати елементи,
щоб розподілити їх рівномірно в новій структурі даних. Це допоможе запобігти колізіям 
та покращити ефективність операцій зчитування та запису.

Написання методу resize дозволить вашій реалізації мапи динамічно збільшуватися та адаптуватися до змін
у кількості даних, що забезпечує більшу гнучкість та ефективність.


## При реалізації методу *resize()*, який допомагає уникати колізій, вам можна використовувати такі кроки:

* Перевірте, чи нова ємність *newCapacity* перевищує *MAX_CAPACITY*, якщо так,
  то зупиніть процес збільшення мапи, оскільки ви досягли максимальної ємності.
* Створіть новий масив елементів *newTable* з розміром *newCapacity*.
* Переберіть всі елементи в старому масиві *table* і перенесіть їх у новий масив *newTable*. 
 #### При цьому використовуйте відповідну стратегію для уникнення колізій:
* Якщо ви використовуєте ***відкрите зв'язування***, додайте елементи з однаковим hash code в зв'язаний список
  для кожного індексу масиву.
* Якщо ви використовуєте ***відкрите зв'язування з ланцюжками***, додайте елементи з однаковим hash code в
 бінарне дерево для кожного індексу масиву.
* Оновіть значення table на новий масив newTable.
* Оновіть значення capacity на нову ємність newCapacity.

#### Це загальна ідея для реалізації методу resize(), що допомагає уникати колізій. 
#### Залежно від вашої конкретної реалізації мапи та вибраної стратегії уникнення колізій, 
#### можуть бути додаткові кроки або нюанси.

